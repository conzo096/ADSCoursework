import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.HashMap;


public class Main
{
	public static double routeLength(ArrayList<Point2D> cities)
	{
		//Calculate the length of a TSP route held in an ArrayList as a set of Points
		double result=0;//Holds the route length
		Point2D prev = cities.get(cities.size()-1);
		//Set the previous city to the last city in the ArrayList as we need
		// to measure the length of the entire loop
		for(Point2D city : cities)
		{
			//Go through each city in turn
			result += city.distance(prev);
			//get distance from the previous city
			prev = city;
			//current city will be the previous city next time
		}
		return result;
	}
	
	public static ArrayList<Point2D> NearestNeighbour(ArrayList<Point2D> inCities)
	{
		ArrayList<Point2D> cities = new ArrayList<Point2D>(inCities);
		ArrayList<Point2D> result = new ArrayList<Point2D>();
		// Set current city.
		Point2D currentCity = cities.get(0);
		
		// Closest city to the current city.
		Point2D closest = null;
		// While cities left in list.
		while (cities.size() >0)
		{
			// Add current city to list.
			result.add(currentCity);
			// Find closest city.
			double distance = Double.MAX_VALUE;
			for(Point2D t : cities)
			{
				if(Point2D.distance(currentCity.getX(), currentCity.getY(), t.getX(), t.getY()) <= distance)
				{
					closest = t;
					distance = Point2D.distance(currentCity.getX(), currentCity.getY(), t.getX(), t.getY());
				}
			}
			cities.remove(closest);
			currentCity = closest;
		}
		return result;	
	}
	
	public static HashMap<Integer,Point2D> NearestNeighbourV1(HashMap<Integer,Point2D> cities)
	{
		HashMap<Integer,Point2D> result = new HashMap<Integer,Point2D>();
			// Current city to visit - set as first in array.
		Point2D currentCity = cities.remove(0);
		// Closest city key to the current city.
		int closest = 0;
		// Keeps track for hashmap.
		int tracker = 0;
		// While cities left in list.
		while (cities.size() >0)
		{
			// Add current city to list.
			result.put(tracker,currentCity);
		//	System.out.println("Current city: "+currentCity.toString());
			// Find closest city.
			double distance = 999999;
			for(int i=0; i < cities.size(); i++)
			{
			//	System.out.println(i);
				if(Point2D.distance(currentCity.getX(), currentCity.getY(), cities.get(i).getX(), cities.get(i).getY()) < distance)
				{
					closest = i;
					distance = Point2D.distance(currentCity.getX(), currentCity.getY(), cities.get(i).getX(), cities.get(i).getY());
				}
			}
			cities.remove(closest);
			currentCity = cities.get(closest);
			tracker++;
		}
		return result;	
	}
	
	// This method is here to ensure that all cities are included.
	public static Boolean CheckLists(ArrayList<Point2D> original, ArrayList<Point2D> results)
	{
		Boolean inList = false;
		for(Point2D x : original)
		{
			for(Point2D y : results)
			{
				if(x == y)
				{
					inList = true;
					break;
				}
				else
					inList = false;
			}
		}
		return inList;
	}
		
	public static void PrintResults(ArrayList<Point2D> original, ArrayList<Point2D> results, double elapsedTime)
	{
		  
		if (CheckLists(original,results))
		{
			double cityDist = routeLength(original);
			double resultDist = routeLength(results);
			System.out.println("Original size: " +original.size() + " | Result size: "+results.size());    
	      
			System.out.println("Original length: " +cityDist + " | Result length: "+resultDist);    
			System.out.println("Time taken: "+ elapsedTime + " milliseconds.");
			DrawRoute route = new DrawRoute();
			route.Route(original);
			DrawRoute route1 = new DrawRoute();
			route1.Route(results);
		}
		else
			System.out.println("Algorithm did not work. Missing cities.");
	}
	
	public static void main(String[] args)
	{
		//	String fName = "..\\src\\rl5915.tsp";
		String fName ="C:\\Users\\conner\\Documents\\GitHub\\ADSCoursework\\ADSCoursework\\src\\rl5915.tsp";
		ArrayList<Point2D> cities = new ArrayList<Point2D>(TsbLoader.loadTSPLib(fName));
		HashMap<Integer,Point2D> hCities = new HashMap<Integer,Point2D>(cities.size());
		for (int i=0; i< cities.size(); i++)
		{
			hCities.put(i,cities.get(i));
		}
	    long startTime = System.currentTimeMillis();
	
	    // INSERT WHAT ALGORITHM TO USE HERE:
		ArrayList<Point2D> results = NearestNeighbour(cities);
	//	HashMap<Integer,Point2D> results = NearestNeighbourV1(hCities);
		long stopTime = System.currentTimeMillis();
	    long elapsedTime = stopTime - startTime;
	    PrintResults(cities,results,elapsedTime);
	   

	}

}
